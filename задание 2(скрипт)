# Установка пакета pymysql

import pymysql.cursors  
import pandas as pd


# Определение функции для установления соединения с базой. Поля host, user, password, db заполняются самостоятельно
def getConnection():
     
    connection = pymysql.connect(host='localhost',
                                 user='root',
                                 password='',                             
                                 db='orders',
                                 charset='utf8mb4',
                                 cursorclass=pymysql.cursors.DictCursor)
    return connection


# Вывод списка инструментов, по которым можно построить очередь заявок

connection = getConnection()
with connection.cursor() as cursor:
        sql = "SELECT seccode FROM security_type order by instrument_type, seccode"
        cursor.execute(sql)
        table = pd.DataFrame(cursor.fetchall())
        print(table)
connection.close()


# Присвоение переменной a значение тикера, данные по которому необходимо запросить. Список доступных тикеров можно получить, выполнив команду выше

a = input('Введите тикер  ')


# Присвоение переменной b момента времени, данные на который необходимо запросить. Момент времени должен быть записан в формате HHMMSSQQQ

b = int(input('Введите момент времени в течение торговой сессий  '))
if (b>0) and (b<235999999):


# Вывод введенных пользователем значений, для того чтобы дать ему возможность проверить правильность введенных значений

print ('Вы запросили очередь заявок по инструменту', a, 'на момент времени', b)
else:
    print ('Введенное время не соответствует требуемому формату')
    b = int(input('Введите момент времени в течение торговой сессий  '))
    print ('Вы запросили очередь заявок по инструменту', a, 'на момент времени', b)


# Вывод всех записей, которые удовлетворяют условиям, введенным пользователем (на данный момент возникает ошибка при написании 'and ordertime <=b', поэтому придется вручную менять число в коде

with connection.cursor() as cursor:
        sql = "SELECT * FROM orders where seccode = 'ALRS' and ordertime <= 100000000"
        cursor.execute(sql)
        print ("cursor.description: ", cursor.description)
        print()
        for row in cursor:
            print(row)


# Вывод списка уровней цен и соответствующих им объемов на стороне BUY

if (seccode = a) and (ordertime <= b) and (buysell = 'B'):
    d == 0 #счетчик накопленного объема
    i == max (price) #выбор максимальной цены, от которой будет происходить отсчет
    for i in range (min(price), max(price)+0.05,0.05):
        d == 0 #счетчик накопленного объема
        if action == 1:
            d == d + volume #увеличение объема, если заявка не исполнена
        else:
            d == d - volume #уменьшение объема, если заявка отменена или исполнена
    print (i, ' ', d) #вывод списка цен и накопленных объемов на каждом уровне цены на стороне BUY
 
 
# Вывод списка уровней цен и соответствующих им объемов на стороне SELL

if (seccode = a) and (ordertime <= b) and (buysell = 'S'):
    f == 0 #счетчик накопленного объема
    j == max (price) #выбор максимальной цены, от которой будет происходить отсчет
    for j in range (min(price), max(price)+0.05,0.05):
        f == 0 #счетчик накопленного объема
        if action == 1:
            f == f + volume #увеличение объема, если заявка не исполнена
        else:
            f == f - volume #уменьшение объема, если заявка отменена или исполнена
    print (j, ' ', f) #вывод списка цен и накопленных объемов на каждом уровне цены на стороне SELL
    
    



